function [Y,varargout] = getYukawaInt_fermions(stateID,DHForCI,m)

% hbar = 1.054571800e-34; % 1.054571800(13)×10−34 J s  (2014 CODATA)
% c = 299792458; % m/s
% a0 = 5.2917721067e-11; % 5.2917721067(12)×10−11 (2014 CODATA)
% eV = 1.6021766208e-19; % J; 1eV = 1.6021766208(98)×10−19 J (2014 CODATA)
% 
% mc2_a0 = hbar*c/a0; % J
% eV2a0 = eV/mc2_a0; % 1 eV ~ 1/3729 mc2_a0
% 
% m_eV = logspace(0,6,100);
% m = m_eV*eV2a0;
% 
% stateID = '1S0';
% DHForCI = 'DHF';

% electron configuration of state
confstr_core = ['1s(2)2s(2)2p-(2)2p(4)',...
    '3s(2)3p-(2)3p(4)3d-(4)3d(6)',...
    '4s(2)4p-(2)4p(4)4d-(4)4d(6)',...
    '5s(2)5p-(2)5p(6)4f-(6)4f(8)'];
confstr_valence = '6s(2)';

% load .w.readrwf and .sum file of subshells
T_orbital = getOrbitals(stateID,DHForCI);
fprintf('   - Wavefunctions loaded.\n')

% load ASF (mixing coeff & csfs) from .rmix (or .crmix) file
[mixc,csf] = readRmix(stateID,DHForCI); % m: m_j=-j,..,j
n_csf = length(mixc);
fprintf('   - ASF loaded; n_csf=%u\n',n_csf)

%% Core
fprintf('   - Core calculation started.\n')
% get list of subshells and occupations from str
expr_lterm = '[spd-z]';
expr_conf = ['(?<subshell>\d+',expr_lterm,'-?)\((?<occupn>\d+)\)'];
conf_core = regexp(confstr_core,expr_conf,'tokens');
conf_core = vertcat(conf_core{:});
conf_core(:,2) = cellfun(@(c) str2double(c),conf_core(:,2),'UniformOutput',false);
N_core = sum([conf_core{:,2}]); % number of core electrons
n_subshell_core = size(conf_core,1);
fprintf('\t- N_core=%u, n_subshell=%u\n',N_core,n_subshell_core)
% calculate Yukawa integration
Y_core_subshell = cell(n_subshell_core,1);
Y_core = zeros(size(m));
fprintf('\t- Integration for core...')
for shi=1:n_subshell_core
    subshell = conf_core{shi,1};
    occupn = conf_core{shi,2};
    rwfn = T_orbital.rwfn{subshell};
    Y = getYukawaInt_simple(T_orbital.rwfn{subshell},m);
%     Y=0;
    Y_core = Y_core + Y*occupn;
    Y_core_subshell{shi} = Y*occupn;
end
fprintf(' Done\n')

%% Valence -- diagonal, population, single-electron density terms
fprintf('   - Valence calculation started.\n')
conf_valence = regexp(confstr_valence,expr_conf,'tokens');
conf_valence = vertcat(conf_valence{:});
conf_valence(:,2) = cellfun(@(c) str2double(c),conf_valence(:,2),'UniformOutput',false);
N = sum([conf_valence{:,2}]); % number of valence electrons
fprintf('\t- N_valence=%u\n',N)

fprintf('\t- Population terms\n')
clear Ylist_pop % list of subshells, its occupation and mixc to avoid redundant integrations
yli = 0;
for csi = 1:n_csf
    n_subshell = size(csf{csi},2);
    Ytemp = 0;
    for shi=1:n_subshell
        subshell = csf{csi}{1,shi};
        occupn = csf{csi}{2,shi};
        rwfn = T_orbital.rwfn{subshell};
        % add subshell to Ylist
        yli = yli + 1;
        Ylist_pop(yli,:) = {subshell,occupn,mixc(csi)};
    end
end
Ylist_pop_subshells = unique(Ylist_pop(:,1),'stable');
n_valence_subshells = length(Ylist_pop_subshells);
Ylist_pop_unique = cell(n_valence_subshells,2); % {subshell,weight}
for yli = 1:n_valence_subshells
    subshell = Ylist_pop_subshells{yli};
    ylInx = find(strcmp(subshell,Ylist_pop(:,1)));
    occupn_temp = vertcat(Ylist_pop{ylInx,2});
    mixc_temp = vertcat(Ylist_pop{ylInx,3});
    weight = sum(occupn_temp.*mixc_temp.^2);
    Ylist_pop_unique(yli,:) = {subshell,weight};
end
fprintf('\t\t-- List of integration generated.\n')
fprintf('\t\t-- Performing integration...')
Y_pop = zeros(size(m));
Y_pop_subshell = cell(n_valence_subshells,1);
% Y_pop_csf = nan(n_csf,1);
for yli = 1:n_valence_subshells
    subshell = Ylist_pop_unique{yli,1};
    weight = Ylist_pop_unique{yli,2};
    Y = getYukawaInt_simple(T_orbital.rwfn{subshell},m);
%     Y = 0;
    Y_pop = Y_pop + Y*weight;
    Y_pop_subshell{yli} = Y*weight;
end
fprintf(' Done.\n')

%% Valence --  correlation terms
fprintf('\t- Correlation terms\n')
% list CSFs in nljm form; fill m from lowest value = -j
csf_nljm = cell(n_csf,1);
for csi = 1:n_csf
    csf_nljm{csi} = cell(3,N); % {[n,l,j,m];subshell;cmpstr}
    n_subshell = size(csf{csi},2);
    ei = 1;
    for shi = 1:n_subshell
        subshell = csf{csi}{1,shi};
        nlj = str2nlj(subshell);
        occupn = csf{csi}{2,shi};
        j = nlj(3);
        mj = (1:occupn) - j -1;
        temp = mat2cell([repmat(nlj,occupn,1),mj.'],ones(1,occupn)).';
        csf_nljm{csi}(1,ei:(ei+occupn-1)) = temp;
        csf_nljm{csi}(2,ei:(ei+occupn-1)) = repmat({subshell},1,occupn);
        csf_nljm{csi}(3,ei:(ei+occupn-1)) = ...
            compose([subshell,'%u'],(1:occupn));
        
        ei = ei + occupn;
    end
end

% calculate integration over all pair csi > csj
fprintf('\t\t-- List of integration being generated...\n')
yli = 0;
clear Ylist_corr
for csi = 1:n_csf
    for csj = 1:csi - 1
        % check if two CSF has minimum difference
        cmpstri = csf_nljm{csi}(3,:);
        cmpstrj = csf_nljm{csj}(3,:);
        ei_diffi = find(~ismember(cmpstri,cmpstrj));
        n_diff = length(ei_diffi);
        if n_diff == 0
            error('the same states.')
        elseif n_diff == 1
            ei_diffj = find(~ismember(cmpstrj,cmpstri));
%             fprintf('%u in csfi and %u in csfj\n',shell_diff1,shell_diff2)
        else
%             fprintf('more difference.\n')
            continue;
        end
%         fprintf('\t\t\t -- test1 passed.\n')
        % check if (l,j,m) == (l',j',m')
        ljmi = csf_nljm{csi}{1,ei_diffi}(2:4);
        ljmj = csf_nljm{csj}{1,ei_diffj}(2:4);
        if ~isequal(ljmi,ljmj)
            continue;
        end
%         fprintf('\t\t\t -- test2 passed.\n')
%         fprintf('\t\t\tcsfi: %s\n',strjoin(cmpstri,' '))
%         fprintf('\t\t\tcsfj: %s\n',strjoin(cmpstrj,' '))
        
        % add subshell to Ylist
        yli = yli + 1;
        phase = (-1)^(ei_diffi-ei_diffj);
        weight = 2*phase*mixc(csi)*mixc(csj);
%         fprintf('\t\t\tphase= %+d\n',phase)
        subshellpair = {csf_nljm{csi}{2,ei_diffi},csf_nljm{csj}{2,ei_diffi}};
        subshellpair = sort(subshellpair);
        cmpstr = strjoin(subshellpair,' ');
        Ylist_corr(yli,:) = ...
            {subshellpair{:},cmpstr,weight}; % {subshell1,subshell2,cmpstr,weight}
    end
end
Ylist_corr_cmpstrs = unique(Ylist_corr(:,3),'stable');
n_corr = length(Ylist_corr_cmpstrs);
Ylist_corr_unique = cell(n_corr,3); 
for yli=1:n_corr
    cmpstr = Ylist_corr_cmpstrs{yli};
    ylInx = find(strcmp(cmpstr,Ylist_corr(:,3)));
    subshellpair = Ylist_corr(ylInx(1),1:2);
    weight = sum([Ylist_corr{ylInx,4}]);
    Ylist_corr_unique(yli,:) = {subshellpair{:},weight}; % {subshell1,subshell2,weight}
end

fprintf('\t\t-- Performing integration...')
Y_corr = zeros(size(m));
Y_corr_subshellpair = cell(n_corr,1);
% Y_corr_csfpair = nan(n_csf,n_csf);
for yli = 1:n_corr
    subshell1 = Ylist_corr_unique{yli,1};
    subshell2 = Ylist_corr_unique{yli,2};
    weight = Ylist_corr_unique{yli,3};
    Y = getYukawaCorrInt_simple(T_orbital.rwfn{subshell1},T_orbital.rwfn{subshell2},m);
%     Y = 0;
    Y_corr = Y_corr + Y*weight;
    Y_corr_subshellpair{yli} = Y*weight;
end
fprintf(' Done\n')

%% Total Yukawa integral and output

Y = Y_core + Y_pop + Y_corr;

varargout{1} = Y_core;
varargout{2} = Y_pop;
varargout{3} = Y_corr;
varargout{4} = Y_pop_subshell;
varargout{5} = Y_corr_subshellpair;
end
